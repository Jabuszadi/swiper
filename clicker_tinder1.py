import time
import random
import os
import io
import requests
import argparse
import re

import torch
import torch.nn as nn
from torchvision import models, transforms
from PIL import Image # Zachowujemy import Image, bo jest potrzebny do wczytywania obrazu z requestsa

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.firefox.options import Options as FirefoxOptions
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, ElementNotInteractableException, NoSuchElementException
from selenium.webdriver.common.action_chains import ActionChains
from webdriver_manager.firefox import GeckoDriverManager

# === DODANO: Parsowanie argument√≥w wiersza polece≈Ñ ===
parser = argparse.ArgumentParser(description="Skrypt do automatycznego swipe'owania na Badoo/Tinder z klasyfikacjƒÖ koloru w≈Ços√≥w.")
parser.add_argument(
    '--preferred-hair-colors',
    nargs='*', # Pozwala na zero lub wiƒôcej argument√≥w po --preferred-hair-colors
    default=[], # Domy≈õlnie pusta lista
    help='Lista nazw kolor√≥w w≈Ços√≥w (np. Blond Black Red) kt√≥re majƒÖ powodowaƒá Swipe Right.'
)
args = parser.parse_args()

# Pobierz listƒô preferowanych kolor√≥w z argument√≥w
PREFERRED_HAIR_COLORS = [color.lower() for color in args.preferred_hair_colors] # Konwertuj na ma≈Çe litery dla sp√≥jno≈õci
print(f"‚ú® Skonfigurowane preferowane kolory w≈Ços√≥w do Swipe Right: {PREFERRED_HAIR_COLORS}")
# =======================================================


# === ≈öcie≈ºka do modelu i konfiguracja modelu ===
# Upewnij siƒô, ≈ºe model_wlosy_best.pt znajduje siƒô w tym samym katalogu co skrypt, lub podaj pe≈ÇnƒÖ ≈õcie≈ºkƒô
MODEL_PATH = "model_wlosy_best.pt"
CLASS_NAMES = ["black", "blonde", "brunette", "redhead"] # Nazwy klas z modelu (pamiƒôtaj o sp√≥jno≈õci z modelem i preferencjami)
# ≈örednie i odchylenia standardowe u≈ºyte do normalizacji (z predict_image.py)
NORM_MEAN = [0.5, 0.5, 0.5]
NORM_STD = [0.5, 0.5, 0.5]

# Transformacje obrazu (musi byƒá takie samo jak przy trenowaniu)
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(NORM_MEAN, NORM_STD)
])

# === SPRAWDZENIE DOSTƒòPNO≈öCI GPU ===
# Workaround dla OMP: Error #15 (z predict_image.py)
os.environ["KMP_DUPLICATE_LIB_OK"]="TRUE"



if not torch.cuda.is_available():
    print("B≈ÅƒÑD: CUDA nie jest dostƒôpne. Ten skrypt wymaga akceleracji GPU do dzia≈Çania modelu predykcyjnego.")
    print("Upewnij siƒô, ≈ºe masz poprawnie zainstalowane PyTorch z obs≈ÇugƒÖ CUDA i kompatybilny sterownik GPU.")
    exit()

device = torch.device("cuda")
print(f"Pomy≈õlnie skonfigurowano u≈ºycie urzƒÖdzenia: {device}")


# üîß Konfiguracja Selenium
TINDER_URL = "https://tinder.com/app/recs" # Adres URL Tindera
SWIPES_LIMIT = 100
MIN_DELAY = 1.5
MAX_DELAY = 3.5

# Selektory (na podstawie wcze≈õniejszych ustale≈Ñ i dostarczonego HTML Badoo)
# Selektor obszaru przycisk√≥w Like/Nope (u≈ºywany do czekania na gotowo≈õƒá strony)
TOOLBAR_SELECTOR = "div.recsToolbar"



# Selektor dla elementu, na kt√≥rym bƒôdziemy emulowaƒá swipe (TW√ìJ POPRAWNY SELEKTOR!)
SWIPE_ELEMENT_SELECTOR = "div.StretchedBox" # <<< TUTAJ JEST TW√ìJ SELEKTOR!
SWIPE_OFFSET_PIXELS = 300 # <<< Okre≈õl, o ile pikseli w prawo przeciƒÖgnƒÖƒá (do≈õwiadczalnie)
SWIPE_LEFT_OFFSET_PIXELS = -300 # <<< Okre≈õl, o ile pikseli w lewo przeciƒÖgnƒÖƒá (do≈õwiadczalnie)


# Selektor dla elementu(√≥w) ZDJƒòCIA PROFILOWEGO na Badoo
# MUSISZ ZIDENTYFIKOWAƒÜ I WSTAWIC POPRAWNY SELEKTOR DLA ELEMENTU IMG LUB INNEGO ZAWIERAJACEGO ZDJECIE
IMAGE_ELEMENT_SELECTOR = "div.StretchedBox" # <<< U≈ºywamy selektora opartego na data-qa


# üîß Opcje przeglƒÖdarki Firefox
# Zdefiniuj ≈õcie≈ºkƒô do katalogu profilu Firefox (WSTAW SWOJƒÑ POPRAWNƒÑ ≈öCIE≈ªKƒò!)
firefox_profile_path = r'C:\Users\adria\AppData\Roaming\Mozilla\Firefox\Profiles\et7jvk0s.Swiper'

options = FirefoxOptions()
options.add_argument("--window-size=1920x1080")

# Wska≈º opcjƒô u≈ºycia konkretnego profilu
options.add_argument(f"-profile")
options.add_argument(firefox_profile_path)

# Ustawienia preferencji dla lokalizacji
options.set_preference("geo.prompt.testing", True)
options.set_preference("geo.prompt.testing.allow", True)

# options.add_argument("--headless") # Mo≈ºesz odkomentowaƒá po debugowaniu, je≈õli nie potrzebujesz widzieƒá okna
options.page_load_strategy = 'normal'

# U≈ºyj GeckoDriverManager do zarzƒÖdzania sterownikiem GeckoDriver dla Firefoxa
service = Service(GeckoDriverManager().install())

# Uruchom przeglƒÖdarkƒô Firefox
driver = webdriver.Firefox(service=service, options=options)

actions = ActionChains(driver)

# --- ZA≈ÅADUJ SW√ìJ MODEL TUTAJ ---
print("‚è≥ ≈Åadowanie modelu predykcyjnego...")
try:
    # <<< KOD DO ≈ÅADOWANIA MODELU Z predict_image.py >>>
    model = models.resnet18(pretrained=False)
    model.fc = nn.Linear(model.fc.in_features, len(CLASS_NAMES))
    # map_location=device zapewnia wczytanie na skonfigurowane urzƒÖdzenie (GPU)
    model.load_state_dict(torch.load(MODEL_PATH, map_location=device))
    model.to(device) # Przenie≈õ model na GPU
    model.eval() # Ustaw model w tryb ewaluacji (wa≈ºne dla predykcji)
    # --------------------------------------------------
    print("‚úÖ Model za≈Çadowany pomy≈õlnie na GPU.")
except FileNotFoundError:
    print(f"‚ùå B≈ÇƒÖd: Plik modelu '{MODEL_PATH}' nie zosta≈Ç znaleziony.")
    print("Upewnij siƒô, ≈ºe plik modelu znajduje siƒô w tym samym katalogu co skrypt lub podaj pe≈ÇnƒÖ ≈õcie≈ºkƒô.")
    driver.quit()
    exit()
except Exception as e:
    print(f"‚ùå B≈ÇƒÖd podczas ≈Çadowania modelu: {e}")
    driver.quit()
    exit()
# ----------------------------------


# üåê Wejd≈∫ na Badoo
driver.get(TINDER_URL)

# Informacja o logowaniu...
print("‚ÑπÔ∏è Skrypt u≈ºywa zapisanego profilu Firefox.")
print("Je≈õli Badoo wymaga logowania, zr√≥b to rƒôcznie w oknie przeglƒÖdarki.")
input("‚ñ∂Ô∏è ENTER po sprawdzeniu/zalogowaniu...")


# ‚úÖ Czekaj na pasek narzƒôdzi (co sugeruje za≈Çadowanie profilu)
# G≈Ç√≥wny blok try dla ca≈Çej interakcji z Badoo
try:
    # Czekaj na widoczno≈õƒá obszaru przycisk√≥w Like/Nope (jako sygna≈Ç gotowo≈õci strony)
    WebDriverWait(driver, 30).until(
        EC.visibility_of_element_located((By.CSS_SELECTOR, TOOLBAR_SELECTOR))
    )
    print("‚úÖ Pasek narzƒôdzi z przyciskami Like/Nope widoczny. Rozpoczynanie symulacji swipe'owania...")

    swiped_count = 0 # Zmienna inicjalizowana w g≈Ç√≥wnym bloku try

    # G≈Ç√≥wna pƒôtla do swipe'owania profili
    while swiped_count < SWIPES_LIMIT:
        
            print(f"\n--- Analizowanie profilu {swiped_count + 1}/{SWIPES_LIMIT} ---") # DODANO: Wyra≈∫ne oddzielenie profili

            #  --- Czekanie na pojawienie siƒô ELEMENTU DO SWIPE'A (profilu) i ZDJƒòCIA PROFILOWEGO ---
            # Zagnie≈ºd≈ºony blok try/except dla czekania na kluczowe elementy
            try:
                # Czekaj na widoczno≈õƒá elementu, na kt√≥rym bƒôdziemy wykonywaƒá gest swipe
                WebDriverWait(driver, 10).until(
                    EC.visibility_of_element_located((By.CSS_SELECTOR, SWIPE_ELEMENT_SELECTOR))
                )
                print("‚úÖ Element do swipe'a widoczny i gotowy.")
                 # Czekaj na obecno≈õƒá elementu zdjƒôcia profilowego
                WebDriverWait(driver, 10).until(
                      EC.presence_of_element_located((By.CSS_SELECTOR, IMAGE_ELEMENT_SELECTOR)) # <<< U≈ºywamy nowego selektora
                )
                print("‚úÖ Zdjƒôcie profilowe obecne i gotowe.")
            except TimeoutException:
                print(f"‚ö†Ô∏è TimeoutException: Nie za≈Çadowano elementu do swipe'a lub zdjƒôcia. Pomi≈Ñ profil.")
                swiped_count += 1 # Zwiƒôksz licznik nawet je≈õli wystƒÖpi b≈ÇƒÖd przy ≈Çadowaniu element√≥w
                continue # Pomi≈Ñ ten profil i przejd≈∫ do nastƒôpnego
            except NoSuchElementException:
                 print(f"‚ö†Ô∏è NoSuchElementException: Nie znaleziono elementu do swipe'a lub zdjƒôcia. Pomi≈Ñ profil.")
                 swiped_count += 1 # Zwiƒôksz licznik nawet je≈õli wystƒÖpi b≈ÇƒÖd przy ≈Çadowaniu element√≥w
                 continue # Pomi≈Ñ ten profil i przejd≈∫ do nastƒôpnego
            # --------------------------------------------------------


            # --- MIEJSCE NA OBS≈ÅUGƒò POTENCJALNYCH POPUP√ìW / NAK≈ÅADEK ---
            # Je≈õli na zrzucie ekranu (debug_screenshot.png, kt√≥ry mo≈ºesz wygenerowaƒá rƒôcznie) widaƒá popupy lub elementy
            # zas≈ÇaniajƒÖce przyciski Like/Nope/obszar swipe'owalny, tutaj nale≈ºy dodaƒá logikƒô do ich zamkniƒôcia.
            # Przyk≈Çady w komentarzach poni≈ºej:
            # try:
            #    close_button = driver.find_element(By.CSS_SELECTOR, "selektor_przycisku_zamkniecia_popupu")
            #    if close_button.is_displayed():
            #        close_button.click()
            #        print("‚ÑπÔ∏è Zamkniƒôto popup.")
            #        time.sleep(1) # Kr√≥tka pauza po zamkniƒôciu
            # except NoSuchElementException:
            #    pass # Nie ma popupu lub nie znaleziono przycisku zamkniƒôcia
            # except Exception as popup_e:
            #    print(f"‚ö†Ô∏è B≈ÇƒÖd podczas zamykania popupu: {popup_e}")


            # Inny przyk≈Çad: naci≈õniƒôcie klawisza ESC, co czƒôsto zamyka popupy
            # try:
            #    body = driver.find_element(By.TAG_NAME, 'body') # Mo≈ºesz potrzebowaƒá znale≈∫ƒá element body je≈õli go nie masz
            #    body.send_keys(Keys.ESCAPE)
            #    print("‚ÑπÔ∏è Naci≈õniƒôto ESC (pr√≥ba zamkniƒôcia popupu).")
            #    time.sleep(1)
            # except NoSuchElementException:
            #    pass
            # except Exception as esc_e:
            #     print(f"‚ö†Ô∏è B≈ÇƒÖd podczas wysy≈Çania ESC: {esc_e}")
            # ------------------------------------------------------------


            # --- POBIERZ ZDJƒòCIA PROFILU I URUCHOM PREDYKCJE ---
            print("üñºÔ∏è Pobieram URL-e zdjƒôƒá profilu...")
            image_urls = []
            try:
                # Znajd≈∫ WSZYSTKIE elementy zdjƒôƒá profilu na stronie (czƒôsto jest ich kilka)
                # U≈ºywamy POPRAWNEGO SELEKTORA ZDJƒòCIA - UZUPE≈ÅNIJ GO NA G√ìRZE SKRYPTU!
                image_elements = driver.find_elements(By.CSS_SELECTOR, IMAGE_ELEMENT_SELECTOR)

                for img_element in image_elements:
                    # Upewnij siƒô, ≈ºe element ma atrybut 'src' i ≈ºe URL nie jest pusty
                    src = img_element.get_attribute("style")
                    # Badoo mo≈ºe u≈ºywaƒá leniwego ≈Çadowania (lazy loading) i URL mo≈ºe byƒá w innym atrybucie, np. data-src
                    if not src or not src.startswith("http"):
                         src = img_element.get_attribute("style")
                         # Sprawd≈∫ te≈º inne atrybuty, np. style='background-image: url(...)'
                         if not src or not src.startswith("http"):
                             style = img_element.get_attribute("style")
                             if style and "background-image" in style:
                                 # WydobƒÖd≈∫ URL z atrybutu style="background-image: url(...)"
                                 match = re.search(r'url\("?(.*?)"?\)', style)
                                 if match:
                                     src = match.group(1)


                    if src and src.startswith("http"): # Sprawd≈∫, czy to prawid≈Çowy URL obrazu
                         image_urls.append(src)

                if not image_urls:
                     print("‚ö†Ô∏è Nie znaleziono URL-i zdjƒôƒá profilu dla selektora:", IMAGE_ELEMENT_SELECTOR, ". Pomi≈Ñ profil.")
                     swiped_count += 1 # Zwiƒôksz licznik, je≈õli nie ma zdjƒôƒá
                     continue # Pomi≈Ñ ten profil i przejd≈∫ do nastƒôpnego

                print(f"‚úÖ Znaleziono {len(image_urls)} URL-i zdjƒôƒá: {image_urls}")

                # --- URUCHOMIENIE PREDYKCJI DLA KA≈ªDEGO ZDJƒòCIA ---
                # Zbieramy top predykcje (lowercase) dla ka≈ºdego zdjƒôcia
                top_predicted_classes_for_profile = []
                with torch.no_grad(): # Wy≈ÇƒÖcz gradienty na czas predykcji (oszczƒôdno≈õƒá pamiƒôci/czasu)
                    for url in image_urls:
                        try:
                            # Pobierz obraz z URL-a
                            response = requests.get(url, stream=True)
                            response.raise_for_status() # Rzuƒá wyjƒÖtek dla z≈Çych kod√≥w statusu (4xx lub 5xx)
                            response.raw.decode_content = True # Dekompresuj gzip/deflate

                            # Otw√≥rz obraz za pomocƒÖ Pillow z danych w pamiƒôci
                            # U≈ºyj io.BytesIO do czytania z bajt√≥w w pamiƒôci
                            image = Image.open(io.BytesIO(response.content)).convert("RGB")

                            # Przetw√≥rz obraz
                            input_tensor = transform(image).unsqueeze(0).to(device) # Dodaj wymiar batcha i przenie≈õ na GPU

                            # Wywo≈Çaj predykcjƒô modelu
                            outputs = model(input_tensor)
                            _, predicted_tensor = torch.max(outputs, 1)
                            predicted_class_idx = predicted_tensor.item() # Przenie≈õ wynik na CPU i pobierz warto≈õƒá skalara

                            # Mapowanie indeksu na nazwƒô klasy
                            if 0 <= predicted_class_idx < len(CLASS_NAMES):
                                predicted_class = CLASS_NAMES[predicted_class_idx]
                                print(f"   -> Predykcja dla {url[:50]}...: {predicted_class.upper()}") # Wypisz fragment URL
                                top_predicted_classes_for_profile.append(predicted_class.lower()) # DODANO: Zapisz top predykcjƒô (lowercase)
                            else:
                                print(f"   -> Warning: Predicted class index ({predicted_class_idx}) out of bounds for {url[:50]}...")
                                # top_predicted_classes_for_profile.append("unknown") # Opcjonalnie dodaj "unknown"
                                pass # Nie dodajemy "unknown" do listy

                        except Exception as pred_e:
                             print(f"   -> ‚ö†Ô∏è B≈ÇƒÖd podczas przetwarzania zdjƒôcia lub predykcji dla {url[:50]}...: {pred_e}")
                             # top_predicted_classes_for_profile.append("error") # Opcjonalnie dodaj "error"
                             pass # Nie dodajemy "error" do listy


                # --- ZMODYFIKOWANA LOGIKA DECYZYJNA (Majority Rule) ---
                # Decyzja: swipe w prawo je≈ºeli WIƒòKSZO≈öƒÜ (powy≈ºej 50%) predykcji dla zdjƒôƒá profilu
                # znajduje siƒô na li≈õcie preferowanych kolor√≥w w≈Ços√≥w

                total_predictions = len(top_predicted_classes_for_profile)
                preferred_color_count = 0

                if total_predictions > 0:
                    # Count how many predictions are in the preferred list
                    for predicted_color in top_predicted_classes_for_profile:
                        if predicted_color in PREFERRED_HAIR_COLORS:
                            preferred_color_count += 1

                    # Determine if preferred colors are the majority
                    should_swipe_right = preferred_color_count > total_predictions / 2
                    print(f"üî¨ Analiza predykcji: Ca≈Çkowita liczba predykcji zdjƒôƒá: {total_predictions}, Predykcji pasujƒÖcych do preferowanych kolor√≥w: {preferred_color_count}")
                else:
                    # No predictions were made
                    should_swipe_right = False
                    print("üî¨ Analiza predykcji: Brak udanych predykcji koloru w≈Ços√≥w dla tego profilu.")


                # DODANO: Logowanie informacji o predykcji i preferencjach dla bie≈ºƒÖcego profilu
                print(f"‚û°Ô∏è Logika decyzji Swipe: Preferowane kolory do Swipe Right: {PREFERRED_HAIR_COLORS}, Decyzja: {'Swipe Right' if should_swipe_right else 'Swipe Left'}")


                if should_swipe_right:
                    # Find which preferred colors were detected (for logging)
                    detected_preferred = [c for c in top_predicted_classes_for_profile if c in PREFERRED_HAIR_COLORS]
                    # Usun duplikaty dla czytelno≈õci w logu
                    unique_detected_preferred = []
                    [unique_detected_preferred.append(item) for item in detected_preferred if item not in unique_detected_preferred]

                    print(f"‚ù§Ô∏è Wykonujƒô Swipe Right. Wykryto preferowany kolor w≈Ços√≥w w wiƒôkszo≈õci ({preferred_color_count}/{total_predictions}) zdjƒôƒá ({', '.join(unique_detected_preferred) if unique_detected_preferred else 'N/A'}).")
                else:
                    # Find which preferred colors *could* have been detected but weren't majority (for logging)
                    detected_non_preferred = [c for c in top_predicted_classes_for_profile if c not in PREFERRED_HAIR_COLORS]
                    # Usun duplikaty
                    unique_detected_non_preferred = []
                    [unique_detected_non_preferred.append(item) for item in detected_non_preferred if item not in unique_detected_non_preferred]
                    detected_preferred_minority = [c for c in top_predicted_classes_for_profile if c in PREFERRED_HAIR_COLORS]
                     # Usun duplikaty
                    unique_detected_preferred_minority = []
                    [unique_detected_preferred_minority.append(item) for item in detected_preferred_minority if item not in unique_detected_preferred_minority]


                    print(f"üëé Wykonujƒô Swipe Left. Wykryty preferowany kolor w≈Ços√≥w ({', '.join(unique_detected_preferred_minority)}) nie stanowi wiƒôkszo≈õci predykcji ({preferred_color_count}/{total_predictions}). DominujƒÖce kolory (niepreferowane): {', '.join(unique_detected_non_preferred) if unique_detected_non_preferred else 'N/A'}.")
                # ---------------------------------------

                # --- WYKONAJ AKCJƒò SWIPE NA PODSTAWIE DECYZJI ---
                # Upewnij siƒô, ≈ºe element do wysy≈Çania klawiszy jest aktywny i widoczny
                try:
                    # Ponownie znajdujemy element, aby upewniƒá siƒô, ≈ºe jest aktualny po ewentualnym za≈Çadowaniu nowego profilu
                    target_element = WebDriverWait(driver, 5).until(
                         EC.visibility_of_element_located((By.CSS_SELECTOR, SWIPE_ELEMENT_SELECTOR))
                    )
                    # Alternatywnie mo≈ºna spr√≥bowaƒá wys≈Çaƒá klawisze do elementu body, je≈õli wysy≈Çanie do swipe_element nie dzia≈Ça
                    # target_element = driver.find_element(By.TAG_NAME, 'body')

                except TimeoutException:
                    print(f"‚ö†Ô∏è TimeoutException: Element docelowy dla klawiszy ({SWIPE_ELEMENT_SELECTOR}) nie by≈Ç widoczny. Pomi≈Ñ profil.")
                    swiped_count += 1 # Zwiƒôksz licznik w przypadku b≈Çƒôdu
                    continue
                except NoSuchElementException:
                     print(f"‚ö†Ô∏è NoSuchElementException: Element docelowy dla klawiszy ({SWIPE_ELEMENT_SELECTOR}) nie znaleziono. Pomi≈Ñ profil.")
                     swiped_count += 1 # Zwiƒôksz licznik w przypadku b≈Çƒôdu
                     continue


                if should_swipe_right:
                    print("‚û°Ô∏è Wykonujƒô Swipe Right (klawisz strza≈Çki w prawo)...")
                    # Wy≈õlij klawisz strza≈Çki w prawo do elementu
                    actions.send_keys(Keys.ARROW_RIGHT).perform()
                    print("‚úÖ Swipe Right wykonany.") # Dodano log potwierdzajƒÖcy
                else:
                    print("‚¨ÖÔ∏è Wykonujƒô Swipe Left (klawisz strza≈Çki w lewo)...")
                    # Wy≈õlij klawisz strza≈Çki w lewo do elementu
                    actions.send_keys(Keys.ARROW_LEFT).perform()
                    print("‚úÖ Swipe Left wykonany.") # Dodano log potwierdzajƒÖcy

                # ------------------------------------------------

                # ZWIƒòKSZ LICZNIK SWIPE'√ìW I ZACZEKAJ (po udanym swipe)
                swiped_count += 1 # Zwiƒôksz licznik tylko po udanym wykonaniu swipe'a
                print(f"‚úÖ Wykonano swipe: {swiped_count}/{SWIPES_LIMIT}")
                delay = random.uniform(MIN_DELAY, MAX_DELAY)
                print(f"‚è≥ Czekam {delay:.2f} sekundy przed nastƒôpnym profilem...")
                time.sleep(delay)

            # Obs≈Çuga wyjƒÖtk√≥w wewnƒÖtrz pƒôtli while (poza zagnie≈ºd≈ºonym try/except dla czekania)
            except NoSuchElementException as e: # Je≈õli element zniknie *po* wstƒôpnym czekaniu, ale przed swipe'em
                 print(f"‚ö†Ô∏è NoSuchElementException (w pƒôtli g≈Ç√≥wnej): Element nie znaleziono podczas przetwarzania ({e}). Mo≈ºliwa zmiana strony lub problem z ≈Çadowaniem.")
                 print("‚åõ Chwila przerwy, pr√≥ba kontynuacji...")
                 time.sleep(5)
                 swiped_count += 1 # Zwiƒôksz licznik, nawet je≈õli wystƒÖpi b≈ÇƒÖd
                 continue # Spr√≥buj nastƒôpny profil
            except TimeoutException as e: # Je≈õli co≈õ trwa za d≈Çugo *po* wstƒôpnym czekaniu
                 print(f"‚ö†Ô∏è TimeoutException: Oczekiwanie na element minƒô≈Ço w pƒôtli. Mo≈ºliwy problem z ≈Çadowaniem kolejnego profilu lub popupy blokujƒÖce.")
                 print("üí° Spr√≥buj dodaƒá logikƒô zamykania popup√≥w/nak≈Çadek w sekcji 'MIEJSCE NA OBS≈ÅUGƒò POTENCJALNYCH POPUPOW'.")
                 print("‚åõ Chwila przerwy, pr√≥ba kontynuacji...")
                 time.sleep(5)
                 swiped_count += 1 # Zwiƒôksz licznik, nawet je≈õli wystƒÖpi timeout
                 continue # Spr√≥buj nastƒôpny profil
            except Exception as e: # Inne b≈Çƒôdy wewnƒÖtrz pƒôtli
                print(f"‚ö†Ô∏è WystƒÖpi≈Ç inny b≈ÇƒÖd podczas przetwarzania profilu lub symulacji swipe'a w pƒôtli g≈Ç√≥wnej: {e}")
                if "badoo.com" not in driver.current_url:
                     print("üõë Opu≈õcili≈õmy Badoo. Ko≈Ñczƒô.")
                     break # Wyj≈õcie z pƒôtli while, je≈õli opu≈õcili≈õmy Badoo
                print("‚åõ Chwila przerwy, mo≈ºliwe okno/popup lub inny problem...")
                time.sleep(5)
                swiped_count += 1 # Zwiƒôksz licznik, nawet je≈õli wystƒÖpi b≈ÇƒÖd og√≥lny
                continue # Spr√≥buj nastƒôpny profil

# Ten blok except obs≈Çuguje TimeoutException z PRED PƒòTLƒÑ WHILE (przy pierwszym ≈Çadowaniu strony)
except TimeoutException:
    print("‚ùå Nie za≈Çadowano profilu ‚Äì mo≈ºliwe ≈ºe nie jeste≈õ zalogowany w profilu Firefox, lub problem z po≈ÇƒÖczeniem.")
    print("Sprawd≈∫ stan przeglƒÖdarki.")

# Ten blok finally wykonuje siƒô zawsze po zako≈Ñczeniu g≈Ç√≥wnego bloku try (lub obs≈Çudze wyjƒÖtku)
finally:
    # swiped_count mo≈ºe nie byƒá zainicjalizowane, je≈õli g≈Ç√≥wny try blok zawi√≥d≈Ç od razu
    print(f"\n‚úÖ Zako≈Ñczono: wykonano {swiped_count if 'swiped_count' in locals() else 0}/{SWIPES_LIMIT} swipe'√≥w.")
    # driver.quit()  # Odkomentuj, je≈õli chcesz zamknƒÖƒá przeglƒÖdarkƒô po zako≈Ñczeniu
