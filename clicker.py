import time
import random
import os
import io
import requests

import torch
import torch.nn as nn
from torchvision import models, transforms
from PIL import Image # Zachowujemy import Image, bo jest potrzebny do wczytywania obrazu z requestsa

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.firefox.options import Options as FirefoxOptions
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, ElementNotInteractableException, NoSuchElementException
from selenium.webdriver.common.action_chains import ActionChains
from webdriver_manager.firefox import GeckoDriverManager

# === ≈öcie≈ºka do modelu i konfiguracja modelu ===
# Upewnij siƒô, ≈ºe model_wlosy_best.pt znajduje siƒô w tym samym katalogu co skrypt, lub podaj pe≈ÇnƒÖ ≈õcie≈ºkƒô
MODEL_PATH = "model_wlosy_best.pt"
CLASS_NAMES = ["black", "blonde", "brunette", "redhead"] # Nazwy klas z modelu
# ≈örednie i odchylenia standardowe u≈ºyte do normalizacji (z predict_image.py)
NORM_MEAN = [0.5, 0.5, 0.5]
NORM_STD = [0.5, 0.5, 0.5]

# Transformacje obrazu (musi byƒá takie samo jak przy trenowaniu)
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(NORM_MEAN, NORM_STD)
])

# === SPRAWDZENIE DOSTƒòPNO≈öCI GPU ===
# Workaround dla OMP: Error #15 (z predict_image.py)
os.environ["KMP_DUPLICATE_LIB_OK"]="TRUE"

if not torch.cuda.is_available():
    print("B≈ÅƒÑD: CUDA nie jest dostƒôpne. Ten skrypt wymaga akceleracji GPU do dzia≈Çania modelu predykcyjnego.")
    print("Upewnij siƒô, ≈ºe masz poprawnie zainstalowane PyTorch z obs≈ÇugƒÖ CUDA i kompatybilny sterownik GPU.")
    exit()

device = torch.device("cuda")
print(f"Pomy≈õlnie skonfigurowano u≈ºycie urzƒÖdzenia: {device}")


# üîß Konfiguracja Selenium
TINDER_URL = "https://am1.badoo.com/encounters" # Adres URL Badoo
SWIPES_LIMIT = 100
MIN_DELAY = 1.5
MAX_DELAY = 3.5

# Selektory (na podstawie wcze≈õniejszych ustale≈Ñ i dostarczonego HTML Badoo)
# Selektor obszaru przycisk√≥w Like/Nope (u≈ºywany do czekania na gotowo≈õƒá strony)
TOOLBAR_SELECTOR = "div.profile-card-full__actions"



# Selektor dla elementu, na kt√≥rym bƒôdziemy emulowaƒá swipe (TW√ìJ POPRAWNY SELEKTOR!)
SWIPE_ELEMENT_SELECTOR = "div.user-section-photo" # <<< TUTAJ JEST TW√ìJ SELEKTOR!
SWIPE_OFFSET_PIXELS = 300 # <<< Okre≈õl, o ile pikseli w prawo przeciƒÖgnƒÖƒá (do≈õwiadczalnie)
SWIPE_LEFT_OFFSET_PIXELS = -300 # <<< Okre≈õl, o ile pikseli w lewo przeciƒÖgnƒÖƒá (do≈õwiadczalnie)


# Selektor dla elementu(√≥w) ZDJƒòCIA PROFILOWEGO na Badoo
# MUSISZ ZIDENTYFIKOWAƒÜ I WSTAWIC POPRAWNY SELEKTOR DLA ELEMENTU IMG LUB INNEGO ZAWIERAJƒÑCEGO ZDJƒòCIE
IMAGE_ELEMENT_SELECTOR = "img[data-qa='multimedia-image']" # <<< U≈ºywamy selektora opartego na data-qa


# üîß Opcje przeglƒÖdarki Firefox
# Zdefiniuj ≈õcie≈ºkƒô do katalogu profilu Firefox (WSTAW SWOJƒÑ POPRAWNƒÑ ≈öCIE≈ªKƒò!)
firefox_profile_path = r'C:\Users\adria\AppData\Roaming\Mozilla\Firefox\Profiles\et7jvk0s.Swiper'

options = FirefoxOptions()
options.add_argument("--window-size=1920x1080")

# Wska≈º opcjƒô u≈ºycia konkretnego profilu
options.add_argument(f"-profile")
options.add_argument(firefox_profile_path)

# Ustawienia preferencji dla lokalizacji
options.set_preference("geo.prompt.testing", True)
options.set_preference("geo.prompt.testing.allow", True)

# options.add_argument("--headless") # Mo≈ºesz odkomentowaƒá po debugowaniu, je≈õli nie potrzebujesz widzieƒá okna
options.page_load_strategy = 'normal'

# U≈ºyj GeckoDriverManager do zarzƒÖdzania sterownikiem GeckoDriver dla Firefoxa
service = Service(GeckoDriverManager().install())

# Uruchom przeglƒÖdarkƒô Firefox
driver = webdriver.Firefox(service=service, options=options)

# --- ZA≈ÅADUJ SW√ìJ MODEL TUTAJ ---
print("‚è≥ ≈Åadowanie modelu predykcyjnego...")
try:
    # <<< KOD DO ≈ÅADOWANIA MODELU Z predict_image.py >>>
    model = models.resnet18(pretrained=False)
    model.fc = nn.Linear(model.fc.in_features, len(CLASS_NAMES))
    # map_location=device zapewnia wczytanie na skonfigurowane urzƒÖdzenie (GPU)
    model.load_state_dict(torch.load(MODEL_PATH, map_location=device))
    model.to(device) # Przenie≈õ model na GPU
    model.eval() # Ustaw model w tryb ewaluacji (wa≈ºne dla predykcji)
    # --------------------------------------------------
    print("‚úÖ Model za≈Çadowany pomy≈õlnie na GPU.")
except FileNotFoundError:
    print(f"‚ùå B≈ÇƒÖd: Plik modelu '{MODEL_PATH}' nie zosta≈Ç znaleziony.")
    print("Upewnij siƒô, ≈ºe plik modelu znajduje siƒô w tym samym katalogu co skrypt lub podaj pe≈ÇnƒÖ ≈õcie≈ºkƒô.")
    driver.quit()
    exit()
except Exception as e:
    print(f"‚ùå B≈ÇƒÖd podczas ≈Çadowania modelu: {e}")
    driver.quit()
    exit()
# ----------------------------------


# üåê Wejd≈∫ na Badoo
driver.get(TINDER_URL)

# Informacja o logowaniu...
print("‚ÑπÔ∏è Skrypt u≈ºywa zapisanego profilu Firefox.")
print("Je≈õli Badoo wymaga logowania, zr√≥b to rƒôcznie w oknie przeglƒÖdarki.")
print("Po zalogowaniu, wr√≥ƒá tutaj i naci≈õnij ENTER, aby kontynuowaƒá.")
input("‚ñ∂Ô∏è ENTER po sprawdzeniu/zalogowaniu...")


# ‚úÖ Czekaj na pasek narzƒôdzi (co sugeruje za≈Çadowanie profilu)
try:
    # Czekaj na widoczno≈õƒá obszaru przycisk√≥w Like/Nope (jako sygna≈Ç gotowo≈õci strony)
    WebDriverWait(driver, 30).until(
        EC.visibility_of_element_located((By.CSS_SELECTOR, TOOLBAR_SELECTOR))
    )
    print("‚úÖ Pasek narzƒôdzi z przyciskami Like/Nope widoczny. Rozpoczynanie symulacji swipe'owania...")

    swiped_count = 0

    while swiped_count < SWIPES_LIMIT:
        try:
            print(f"üî¨ Analizowanie profilu {swiped_count + 1}/{SWIPES_LIMIT}...")

            # --- Czekanie na pojawienie siƒô ELEMENTU DO SWIPE'A (profilu) ---
            # Czekaj na widoczno≈õƒá elementu, na kt√≥rym bƒôdziemy wykonywaƒá gest swipe
            WebDriverWait(driver, 10).until(
                EC.visibility_of_element_located((By.CSS_SELECTOR, SWIPE_ELEMENT_SELECTOR))
            )
            print("‚úÖ Element do swipe'a widoczny i gotowy.")
             # --- Czekanie na pojawienie siƒô ZDJƒòCIA PROFILOWEGO ---
             # Czekaj na obecno≈õƒá elementu zdjƒôcia profilowego, aby mieƒá pewno≈õƒá, ≈ºe zdjƒôcie jest w DOM
            WebDriverWait(driver, 10).until(
                  EC.presence_of_element_located((By.CSS_SELECTOR, IMAGE_ELEMENT_SELECTOR)) # <<< U≈ºywamy nowego selektora
            )
            print("‚úÖ Zdjƒôcie profilowe obecne i gotowe.")
            # --------------------------------------------------------

            # --- MIEJSCE NA OBS≈ÅUGƒò POTENCJALNYCH POPUP√ìW / NAK≈ÅADEK ---
            # Je≈õli na zrzucie ekranu (debug_screenshot.png, kt√≥ry mo≈ºesz wygenerowaƒá rƒôcznie) widaƒá popupy lub elementy
            # zas≈ÇaniajƒÖce przyciski Like/Nope/obszar swipe'owalny, tutaj nale≈ºy dodaƒá logikƒô do ich zamkniƒôcia.
            # Przyk≈Çady w komentarzach poni≈ºej:
            # try:
            #    close_button = driver.find_element(By.CSS_SELECTOR, "selektor_przycisku_zamkniecia_popupu")
            #    if close_button.is_displayed():
            #        close_button.click()
            #        print("‚ÑπÔ∏è Zamkniƒôto popup.")
            #        time.sleep(1) # Kr√≥tka pauza po zamkniƒôciu
            # except NoSuchElementException:
            #    pass # Nie ma popupu lub nie znaleziono przycisku zamkniƒôcia
            # except Exception as popup_e:
            #    print(f"‚ö†Ô∏è B≈ÇƒÖd podczas zamykania popupu: {popup_e}")


            # Inny przyk≈Çad: naci≈õniƒôcie klawisza ESC, co czƒôsto zamyka popupy
            # try:
            #    body = driver.find_element(By.TAG_NAME, 'body') # Mo≈ºesz potrzebowaƒá znale≈∫ƒá element body je≈õli go nie masz
            #    body.send_keys(Keys.ESCAPE)
            #    print("‚ÑπÔ∏è Naci≈õniƒôto ESC (pr√≥ba zamkniƒôcia popupu).")
            #    time.sleep(1)
            # except NoSuchElementException:
            #    pass
            # except Exception as esc_e:
            #     print(f"‚ö†Ô∏è B≈ÇƒÖd podczas wysy≈Çania ESC: {esc_e}")
            # ------------------------------------------------------------


            # --- POBIERZ ZDJƒòCIA PROFILU I URUCHOM PREDYKCJƒò ---
            print("üñºÔ∏è Pobieram URL-e zdjƒôƒá profilu...")
            image_urls = []
            try:
                # Znajd≈∫ WSZYSTKIE elementy zdjƒôƒá profilu na stronie (czƒôsto jest ich kilka)
                # U≈ºywamy POPRAWNEGO SELEKTORA ZDJƒòCIA - UZUPE≈ÅNIJ GO NA G√ìRZE SKRYPTU!
                image_elements = driver.find_elements(By.CSS_SELECTOR, IMAGE_ELEMENT_SELECTOR)

                for img_element in image_elements:
                    # Upewnij siƒô, ≈ºe element ma atrybut 'src' i ≈ºe URL nie jest pusty
                    src = img_element.get_attribute("src")
                    # Badoo mo≈ºe u≈ºywaƒá leniwego ≈Çadowania (lazy loading) i URL mo≈ºe byƒá w innym atrybucie, np. data-src
                    if not src or not src.startswith("http"):
                         src = img_element.get_attribute("data-src")
                         # Sprawd≈∫ te≈º inne atrybuty, np. style='background-image: url(...)'
                         if not src or not src.startswith("http"):
                             style = img_element.get_attribute("style")
                             if style and "background-image" in style:
                                 # WydobƒÖd≈∫ URL z atrybutu style="background-image: url(...)"
                                 import re
                                 match = re.search(r'url\("?(.*?)"?\)', style)
                                 if match:
                                     src = match.group(1)


                    if src and src.startswith("http"): # Sprawd≈∫, czy to prawid≈Çowy URL obrazu
                         image_urls.append(src)

                if not image_urls:
                     print("‚ö†Ô∏è Nie znaleziono URL-i zdjƒôƒá profilu dla selektora:", IMAGE_ELEMENT_SELECTOR, ". Pomi≈Ñ profil.")
                     continue # Pomi≈Ñ ten profil i przejd≈∫ do nastƒôpnego

                print(f"‚úÖ Znaleziono {len(image_urls)} URL-i zdjƒôƒá: {image_urls}")

                # --- URUCHOMIENIE PREDYKCJI DLA KA≈ªDEGO ZDJƒòCIA ---
                predicted_classes = []
                with torch.no_grad(): # Wy≈ÇƒÖcz gradienty na czas predykcji (oszczƒôdno≈õƒá pamiƒôci/czasu)
                    for url in image_urls:
                        try:
                            # Pobierz obraz z URL-a
                            response = requests.get(url, stream=True)
                            response.raise_for_status() # Rzuƒá wyjƒÖtek dla z≈Çych kod√≥w statusu (4xx lub 5xx)
                            response.raw.decode_content = True # Dekompresuj gzip/deflate

                            # Otw√≥rz obraz za pomocƒÖ Pillow z danych w pamiƒôci
                            # U≈ºyj io.BytesIO do czytania z bajt√≥w w pamiƒôci
                            image = Image.open(io.BytesIO(response.content)).convert("RGB")

                            # Przetw√≥rz obraz
                            input_tensor = transform(image).unsqueeze(0).to(device) # Dodaj wymiar batcha i przenie≈õ na GPU

                            # Wywo≈Çaj predykcjƒô modelu
                            outputs = model(input_tensor)
                            _, predicted_tensor = torch.max(outputs, 1)
                            predicted_class_idx = predicted_tensor.item() # Przenie≈õ wynik na CPU i pobierz warto≈õƒá skalara

                            # Mapowanie indeksu na nazwƒô klasy
                            if 0 <= predicted_class_idx < len(CLASS_NAMES):
                                predicted_class = CLASS_NAMES[predicted_class_idx]
                                print(f"   -> Predykcja dla {url[:50]}...: {predicted_class.upper()}") # Wypisz fragment URL
                                predicted_classes.append(predicted_class)
                            else:
                                print(f"   -> Warning: Predicted class index ({predicted_class_idx}) out of bounds for {url[:50]}...")
                                predicted_classes.append("unknown") # Dodaj "unknown" je≈õli indeks poza zakresem

                        except Exception as pred_e:
                             print(f"   -> ‚ö†Ô∏è B≈ÇƒÖd podczas przetwarzania zdjƒôcia lub predykcji dla {url[:50]}...: {pred_e}")
                             predicted_classes.append("error") # Zapisz b≈ÇƒÖd jako wynik

                # --- LOGIKA DECYZYJNA ---
                # Decyzja: swipe w prawo je≈õli CO NAJMNIEJ JEDNO zdjƒôcie zosta≈Ço sklasyfikowane jako "brunette"
                final_prediction_is_brunette = "brunette" in predicted_classes
                print(f"‚û°Ô∏è Finalna predykcja dla profilu: Brunette: {final_prediction_is_brunette}")

            except NoSuchElementException: # Obs≈Çu≈º b≈ÇƒÖd je≈õli selektor zdjƒôƒá nie dzia≈Ça
                 print(f"‚ö†Ô∏è NoSuchElementException: Nie znaleziono elementu(√≥w) zdjƒôcia profilowego dla selektora ({IMAGE_ELEMENT_SELECTOR}). Pomi≈Ñ profil.")
                 continue # Pomi≈Ñ ten profil i przejd≈∫ do nastƒôpnego
            except Exception as photo_e: # Obs≈Çu≈º inne b≈Çƒôdy podczas pobierania URL-i zdjƒôƒá lub predykcji
                 print(f"‚ö†Ô∏è B≈ÇƒÖd podczas pobierania URL-i zdjƒôƒá lub predykcji: {photo_e}. Pomi≈Ñ profil.")
                 continue # Pomi≈Ñ ten profil i przejd≈∫ do nastƒôpnego


            # --- AKCJA: Symulujemy swipe w oparciu o predykcjƒô ---
            # Znajd≈∫ element, na kt√≥rym bƒôdziemy wykonywaƒá swipe (czekali≈õmy na niego wcze≈õniej)
            try:
                swipe_element = driver.find_element(By.CSS_SELECTOR, SWIPE_ELEMENT_SELECTOR)
                actions = ActionChains(driver) # Utw√≥rz obiekt ActionChains

                if final_prediction_is_brunette:
                    print(f"‚ù§Ô∏è Predykcja: Brunetka. Symulujƒô swipe w prawo o {SWIPE_OFFSET_PIXELS} pikseli.")
                    # Wykonaj gest drag_and_drop_by_offset na znalezionym elemencie w prawo
                    actions.drag_and_drop_by_offset(swipe_element, SWIPE_OFFSET_PIXELS, 0).perform() # 0 dla osi Y
                else:
                    print(f"üëé Predykcja: Nie-Brunetka. Symulujƒô swipe w lewo o {abs(SWIPE_LEFT_OFFSET_PIXELS)} pikseli.")
                    # Wykonaj gest drag_and_drop_by_offset na znalezionym elemencie w lewo
                    actions.drag_and_drop_by_offset(swipe_element, SWIPE_LEFT_OFFSET_PIXELS, 0).perform() # Ujemna warto≈õƒá dla lewej
                # -------------------------------------------------

            except NoSuchElementException:
                print(f"‚ö†Ô∏è NoSuchElementException: Element do swipe'a ({SWIPE_ELEMENT_SELECTOR}) nie zosta≈Ç znaleziony tu≈º przed akcjƒÖ. Pomi≈Ñ profil.")
                # To nie powinno siƒô zdarzyƒá, je≈õli czekali≈õmy na niego wcze≈õniej, ale jako fallback.
                continue
            except Exception as action_e:
                 print(f"‚ö†Ô∏è B≈ÇƒÖd podczas wykonywania gestu swipe: {action_e}. Pomi≈Ñ profil.")
                 continue # Pomi≈Ñ ten profil w razie b≈Çƒôdu swipe

            
            swiped_count += 1
            delay = random.uniform(MIN_DELAY, MAX_DELAY)
            print(f"‚è≥ Czekanie {delay:.2f} sekundy przed kolejnym swipe'em...")
            time.sleep(delay)

        except NoSuchElementException as e: # Obs≈Çuga b≈Çƒôdu NoSuchElement w pƒôtli (powinien byƒá przechwycony wcze≈õniej, ale jako fallback)
             print(f"‚ö†Ô∏è NoSuchElementException (w pƒôtli g≈Ç√≥wnej): Element nie znaleziono podczas przetwarzania ({e}). Mo≈ºliwa zmiana strony lub problem z ≈Çadowaniem.")
             print("‚åõ Chwila przerwy, pr√≥ba kontynuacji...")
             time.sleep(5)
             continue
        except TimeoutException: # Obs≈Çuga b≈Çƒôdu Timeout podczas czekania na elementy w pƒôtli
             print(f"‚ö†Ô∏è TimeoutException: Oczekiwanie na element minƒô≈Ço w pƒôtli. Mo≈ºliwy problem z ≈Çadowaniem kolejnego profilu lub popupy blokujƒÖce.")
             print("üí° Spr√≥buj dodaƒá logikƒô zamykania popup√≥w/nak≈Çadek w sekcji 'MIEJSCE NA OBS≈ÅUGƒò POTENCJALNYCH POPUP√ìW'.")
             print("‚åõ Chwila przerwy, pr√≥ba kontynuacji...")
             time.sleep(5)
             continue
        except Exception as e:
            print(f"‚ö†Ô∏è WystƒÖpi≈Ç inny b≈ÇƒÖd podczas przetwarzania profilu lub symulacji swipe'a w pƒôtli g≈Ç√≥wnej: {e}")
            if "badoo.com" not in driver.current_url:
                 print("üõë Opu≈õcili≈õmy Badoo. Ko≈Ñczƒô.")
                 break
            print("‚åõ Chwila przerwy, mo≈ºliwe okno/popup lub inny problem...")
            time.sleep(5)
            continue

except TimeoutException:
    print("‚ùå Nie za≈Çadowano profilu ‚Äì mo≈ºliwe ≈ºe nie jeste≈õ zalogowany w profilu Firefox, lub problem z po≈ÇƒÖczeniem.")
    print("Sprawd≈∫ stan przeglƒÖdarki.")

finally:
    print(f"\n‚úÖ Zako≈Ñczono: wykonano {swiped_count if 'swiped_count' in locals() else 0}/{SWIPES_LIMIT} swipe'√≥w.")
    # driver.quit()  # Odkomentuj, je≈õli chcesz zamknƒÖƒá przeglƒÖdarkƒô po zako≈Ñczeniu
